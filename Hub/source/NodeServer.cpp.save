#include "NodeServer.hpp"

//using boost::asio;

Hub::NodeServer::NodeServer(function<void(Node&)> cbConnect) :
			asyncThread([this](){
				ThreadRoutine();}),
			tcpAcceptor(ioService) {
	//this->cbConnect = cbConnect;
//	tcpAcceptor.reset(new boost::asio::ip::tcp::acceptor(ioService,
//			boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), 80)));

	boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 80);

	tcpAcceptor.open(endpoint.protocol());
	tcpAcceptor.bind(endpoint);
}

void Hub::NodeServer::Start() {
	Node *newNode = new Node(bind(&Hub::NodeServer::cbConnect, this, std::placeholders::_1),
				bind(&Hub::NodeServer::cbNodeReadPacket, this, std::placeholders::_1));

	tcpAcceptor.async_accept(newNode->GetSocket(),
			bind(&AcceptHandler, this, newNode,
			:asio::placeholders::error));
}

void Hub::NodeServer::ThreadRoutine() {
	cout << "Starting NodeServer async thread." << endl;
	ioService.run();
}

void Hub::NodeServer::AcceptHandler(Node *newNode, const boost::system::error_code& error) {
	if(!error) {
		//newNode->Start();
		connectedNodes.push_back(newNode);
		cout << "New node connected." << endl;
	}
	else {
		delete newNode;
		cout << "General Boost ASIO async_accept error." << endl;
	}

	Start();
}

bool Hub::NodeServer::IsNodeConnected(uint64_t id) {
	for(auto &node : connectedNodes) {
		if(node.GetID() == id) {
			return true;
		}
	}

	return false;
}

Node& Hub::NodeServer::GetNode(uint64_t id) {
	for(auto &node : connectedNodes) {
		if(node.GetID() == id) {
			return node;
		}
	}

	throw Exception("NodeServer::GetNode exception: node " + to_string(id) " not found");
}

void Hub::NodeServer::RemoveNode(Node* node) {
	connectedNodes.erase(remove(connectedNodes.begin(), connectedNodes.end(), node),
				connectedNodes.end());
}

void Hub::NodeServer::cbNodeClose(Node* node) {
	RemoveNode(node);

	delete node;
}

void Hub::NodeServer::cbNodeReadPacket(Node* node) {
	//TODO: something
}
